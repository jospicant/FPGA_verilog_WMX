// Code generated by Icestudio 0.7.1w202109100309

`default_nettype none

//---- Top entity
module main #(
 parameter vb0b594 = "vb0b594.list"
) (
 input vclk,
 output [7:0] vde1678
);
 localparam p2 = vb0b594;
 wire w0;
 wire [0:7] w1;
 wire [0:2] w3;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 assign vde1678 = w1;
 assign w5 = vclk;
 assign w6 = vclk;
 assign w7 = vclk;
 assign w6 = w5;
 assign w7 = w5;
 assign w7 = w6;
 v725b7e v6f50b5 (
  .v9fb85f(w0)
 );
 v764691 v85ba86 (
  .vf4a676(w3),
  .v7c533e(w4),
  .vdd729a(w5)
 );
 main_v3ef41b #(
  .rom(p2)
 ) v3ef41b (
  .RW(w0),
  .datoOut(w1),
  .direccion(w3),
  .clk(w6)
 );
 va9a5bc vcce1db (
  .v2a8434(w4),
  .vac0eb2(w7)
 );
endmodule

/*-------------------------------------------------*/
/*--   */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- 
/*-------------------------------------------------*/
//---- Top entity
module v725b7e (
 output v9fb85f
);
 wire w0;
 assign v9fb85f = w0;
 v725b7e_vb2eccd vb2eccd (
  .q(w0)
 );
endmodule

/*-------------------------------------------------*/
/*-- 1  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Un bit constante a 1
/*-------------------------------------------------*/

module v725b7e_vb2eccd (
 output q
);
 //-- Bit constante a 1
 assign q = 1'b1;
 
 
endmodule
//---- Top entity
module v764691 #(
 parameter v5e4a03 = 8
) (
 input vdd729a,
 input v7c533e,
 output [2:0] vf4a676,
 output v712cd1
);
 localparam p0 = v5e4a03;
 wire w1;
 wire w2;
 wire w3;
 wire [0:2] w4;
 assign w1 = v7c533e;
 assign w2 = vdd729a;
 assign v712cd1 = w3;
 assign vf4a676 = w4;
 v764691_vbd6086 #(
  .M(p0)
 ) vbd6086 (
  .cnt(w1),
  .clk(w2),
  .ov(w3),
  .q(w4)
 );
endmodule

/*-------------------------------------------------*/
/*-- Contador-3bits-up-rst  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Contador módulo M, ascendente, de 3 bits
/*-------------------------------------------------*/

module v764691_vbd6086 #(
 parameter M = 0
) (
 input clk,
 input cnt,
 output [2:0] q,
 output ov
);
 //-- Numero de bits del contador
 localparam N = 3; 
 
 //-- En contadores de N bits:
 //-- M = 2 ** N
 
 //-- Internamente usamos un bit mas
 //-- (N+1) bits
 reg [N:0] qi = 0;
 
 always @(posedge clk)
   if (ov)
     qi <= 2'b00;
   else
     if (cnt)
       qi <= qi + 1;
       
 assign q = qi;
 
 //-- Comprobar overflow
 assign ov = (qi == M);
     
endmodule
//---- Top entity
module va9a5bc #(
 parameter vfb06ae = 1
) (
 input vac0eb2,
 output v2a8434
);
 localparam p2 = vfb06ae;
 wire w0;
 wire w1;
 assign v2a8434 = w0;
 assign w1 = vac0eb2;
 va9a5bc_v6cac2f #(
  .SEC(p2)
 ) v6cac2f (
  .o(w0),
  .clk(w1)
 );
endmodule

/*-------------------------------------------------*/
/*-- Corazon-tic-Sec  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Corazón de bombeo de tics a con periodo paramétrico de segundos
/*-------------------------------------------------*/

module va9a5bc_v6cac2f #(
 parameter SEC = 0
) (
 input clk,
 output o
);
 //localparam SEC;
 
 //-- Constante para dividir y obtener una frecuencia de 1Hz
 localparam M = 12000000*SEC;
 
 //-- Calcular el numero de bits para almacenar M
 localparam N = $clog2(M);
 
 //-- Cable de reset para el contador
 wire reset;
 
 //-- Registro del divisor
 reg [N-1:0] divcounter;
 
 
 //-- Contador con reset
 always @(posedge clk)
   if (reset)
     divcounter <= 0;
   else
     divcounter <= divcounter + 1;
 
 //-- Comparador que resetea el contador cuando se alcanza el tope
 assign reset = (divcounter == M-1);
 
 //-- La salida es la señal de overflow
 assign o = reset;
 
 
 
 
endmodule

module main_v3ef41b #(
 parameter rom = 0
) (
 input [2:0] direccion,
 input [7:0] datoIn,
 input RW,
 input clk,
 output [7:0] datoOut
);
 
 reg [7:0] memoria[0:7];
 reg [7:0] datoOut;
 
 
 always @(posedge clk)
 begin
    if(RW) //leer
      datoOut<=memoria[direccion]; 
    else // Escribir
      memoria[direccion]<=datoIn;
 end
 
 //-- Inicializacion de la memoria
 initial begin
   
   if (rom)
     $readmemh(rom, memoria, 0, 7);
   
 end
endmodule
