// Code generated by Icestudio 0.7.1w202109100309

`default_nettype none

//---- Top entity
module main (
 input vb9696a,
 input vclk,
 output v4ccc0f,
 output v5b34bd,
 output [0:5] vinit
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 assign w2 = vb9696a;
 assign v4ccc0f = w3;
 assign v5b34bd = w4;
 assign w6 = vclk;
 assign w7 = vclk;
 assign w7 = w6;
 v21cfcc vde1a7e (
  .v9fb85f(w0)
 );
 v2107ac v7b66e5 (
  .v64879c(w1),
  .vd9601b(w2),
  .vbbbce8(w6)
 );
 v4a5269 v6997f7 (
  .v5a79c2(w0),
  .vc47414(w1),
  .v4c90d0(w3),
  .vab7a8c(w4),
  .v009406(w5)
 );
 v5b3e69 v16c5f4 (
  .v8337bc(w5),
  .v531e20(w7)
 );
 assign vinit = 6'b000000;
endmodule

/*-------------------------------------------------*/
/*--   */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- 
/*-------------------------------------------------*/
//---- Top entity
module v21cfcc (
 output v9fb85f
);
 wire w0;
 assign v9fb85f = w0;
 v21cfcc_vb2eccd vb2eccd (
  .q(w0)
 );
endmodule

/*-------------------------------------------------*/
/*-- 0  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Un bit constante a 0
/*-------------------------------------------------*/

module v21cfcc_vb2eccd (
 output q
);
 //-- Bit constante a 0
 assign q = 1'b0;
 
 
endmodule
//---- Top entity
module v2107ac (
 input vbbbce8,
 input vd9601b,
 output v157a67,
 output v64879c
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 assign w0 = vd9601b;
 assign v64879c = w1;
 assign w2 = vbbbce8;
 assign v157a67 = w3;
 v2107ac_v297cb2 v297cb2 (
  .d(w0),
  .tic(w1),
  .clk(w2),
  .state(w3)
 );
endmodule

/*-------------------------------------------------*/
/*-- Pulsador-tic  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Detección de pulsación. Emite un tic cada vez que se aprieta el pulsador
/*-------------------------------------------------*/

module v2107ac_v297cb2 (
 input clk,
 input d,
 output state,
 output tic
);
 // Sincronizacion. Evitar 
 // problema de la metaestabilidad
 
 reg d2;
 reg r_in;
 
 always @(posedge clk)
  d2 <= d;
  
 always @(posedge clk)
   r_in <= d2;
 
 
 //-- Debouncer Circuit
 //-- It produces a stable output when the
 //-- input signal is bouncing
 
 reg btn_prev = 0;
 reg btn_out_r = 0;
 
 reg [16:0] counter = 0;
 
 
 always @(posedge clk) begin
 
   //-- If btn_prev and btn_in are differents
   if (btn_prev ^ r_in == 1'b1) begin
     
       //-- Reset the counter
       counter <= 0;
       
       //-- Capture the button status
       btn_prev <= r_in;
   end
     
   //-- If no timeout, increase the counter
   else if (counter[16] == 1'b0)
       counter <= counter + 1;
       
   else
     //-- Set the output to the stable value
     btn_out_r <= btn_prev;
 
 end
 
 //-- Generar tic en flanco de subida del boton
 reg old;
 
 always @(posedge clk)
   old <= btn_out_r;
   
 assign tic = !old & btn_out_r;
 
 //-- El estado del pulsador se saca por state
 assign state = btn_out_r;
 
 
endmodule
//---- Top entity
module v4a5269 #(
 parameter vef4502 = 5
) (
 input vc47414,
 input v5a79c2,
 input v009406,
 output [10:0] v969c6c,
 output v4c90d0,
 output vab7a8c
);
 localparam p0 = vef4502;
 wire w1;
 wire w2;
 wire w3;
 wire [0:10] w4;
 wire w5;
 wire w6;
 assign w1 = vc47414;
 assign w2 = v5a79c2;
 assign w3 = v009406;
 assign v969c6c = w4;
 assign v4c90d0 = w5;
 assign vab7a8c = w6;
 v4a5269_v6f6a4b #(
  .M(p0)
 ) v6f6a4b (
  .Start(w1),
  .reset(w2),
  .clk(w3),
  .Q(w4),
  .Pulso(w5),
  .ov(w6)
 );
endmodule

/*-------------------------------------------------*/
/*-- 100us  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Al pulsar Start arranca y  se crea un pulso de 100us
/*-------------------------------------------------*/

module v4a5269_v6f6a4b #(
 parameter M = 0
) (
 input Start,
 input reset,
 input clk,
 output [10:0] Q,
 output Pulso,
 output ov
);
 //-- Numero de bits del contador
 localparam N = 11; 
 
 reg [N:0] qi = 0;
 reg       on = 0;
 
 
 always @(posedge clk)
 begin
 
   if (reset | ov) begin qi <= 0; on <=0; end
   else
     begin
         if (Start) on <= 1;
         if (on)    qi <= qi + 1;
     end
 end      
 
 
 assign Q = qi;
 assign Pulso = on;
 assign ov = (qi == M);
     
endmodule
//---- Top entity
module v5b3e69 #(
 parameter v207e0d = 1
) (
 input v531e20,
 output v8337bc
);
 localparam p2 = v207e0d;
 wire w0;
 wire w1;
 assign v8337bc = w0;
 assign w1 = v531e20;
 v5b3e69_v94c6d7 #(
  .SEG(p2)
 ) v94c6d7 (
  .clk_o(w0),
  .clk(w1)
 );
endmodule

/*-------------------------------------------------*/
/*-- Corazon_Seg  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Bombear 1 bit con el periodo especificado en el parámetro. Por defecto el periodo es de 1 segundos
/*-------------------------------------------------*/

module v5b3e69_v94c6d7 #(
 parameter SEG = 0
) (
 input clk,
 output clk_o
);
 
 //parameter HZ=1;
 
 //-- Constante para dividir y obtener una frecuencia de 1Hz
 localparam M = 12000000*SEG;
 
 //-- Calcular el numero de bits para almacenar M
 localparam N = $clog2(M);
 
 //-- Registro del divisor
 reg [N-1:0] divcounter;
 
 //-- Temporal clock
 reg clk_t = 0;
 
 //-- Se usa un contador modulo M/2 para luego
 //-- pasarlo por un biestable T y dividir la frecuencia
 //-- entre 2, para que el ciclo de trabajo sea del 50%
 always @(posedge clk)
     if (divcounter == M/2) begin
       clk_t <= 1;
       divcounter = 0;
     end 
     else begin
       divcounter <=  divcounter + 1;
       clk_t = 0;
     end 
   
 reg clk_o = 0;  
     
 //-- Biestable T para obtener ciclo de trabajo del 50%
 always @(posedge clk)
   if (clk_t)
     clk_o <= ~clk_o;
 
endmodule
