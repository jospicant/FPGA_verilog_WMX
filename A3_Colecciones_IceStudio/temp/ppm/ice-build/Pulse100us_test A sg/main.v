// Code generated by Icestudio 0.7.1w202109100309

`default_nettype none

//---- Top entity
module main (
 input vaf8802,
 input v9d1f5f,
 input vclk,
 output vec30f0,
 output vbc1d8b,
 output [0:5] vinit
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 assign w1 = vaf8802;
 assign w2 = v9d1f5f;
 assign vec30f0 = w3;
 assign vbc1d8b = w4;
 assign w5 = vclk;
 assign w6 = vclk;
 assign w6 = w5;
 v2107ac v8c1a3e (
  .v64879c(w0),
  .vd9601b(w1),
  .vbbbce8(w5)
 );
 vcd88e2 v0bc447 (
  .v826ea3(w0),
  .ve99f77(w2),
  .v5faa99(w3),
  .v1891e5(w4),
  .v30e6b7(w6)
 );
 assign vinit = 6'b000000;
endmodule

/*-------------------------------------------------*/
/*--   */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- 
/*-------------------------------------------------*/
//---- Top entity
module v2107ac (
 input vbbbce8,
 input vd9601b,
 output v157a67,
 output v64879c
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 assign w0 = vd9601b;
 assign v64879c = w1;
 assign w2 = vbbbce8;
 assign v157a67 = w3;
 v2107ac_v297cb2 v297cb2 (
  .d(w0),
  .tic(w1),
  .clk(w2),
  .state(w3)
 );
endmodule

/*-------------------------------------------------*/
/*-- Pulsador-tic  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Detección de pulsación. Emite un tic cada vez que se aprieta el pulsador
/*-------------------------------------------------*/

module v2107ac_v297cb2 (
 input clk,
 input d,
 output state,
 output tic
);
 // Sincronizacion. Evitar 
 // problema de la metaestabilidad
 
 reg d2;
 reg r_in;
 
 always @(posedge clk)
  d2 <= d;
  
 always @(posedge clk)
   r_in <= d2;
 
 
 //-- Debouncer Circuit
 //-- It produces a stable output when the
 //-- input signal is bouncing
 
 reg btn_prev = 0;
 reg btn_out_r = 0;
 
 reg [16:0] counter = 0;
 
 
 always @(posedge clk) begin
 
   //-- If btn_prev and btn_in are differents
   if (btn_prev ^ r_in == 1'b1) begin
     
       //-- Reset the counter
       counter <= 0;
       
       //-- Capture the button status
       btn_prev <= r_in;
   end
     
   //-- If no timeout, increase the counter
   else if (counter[16] == 1'b0)
       counter <= counter + 1;
       
   else
     //-- Set the output to the stable value
     btn_out_r <= btn_prev;
 
 end
 
 //-- Generar tic en flanco de subida del boton
 reg old;
 
 always @(posedge clk)
   old <= btn_out_r;
   
 assign tic = !old & btn_out_r;
 
 //-- El estado del pulsador se saca por state
 assign state = btn_out_r;
 
 
endmodule
//---- Top entity
module vcd88e2 (
 input v826ea3,
 input ve99f77,
 input v30e6b7,
 output v5faa99,
 output v1891e5
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 assign w0 = v826ea3;
 assign w1 = ve99f77;
 assign w2 = v30e6b7;
 assign v5faa99 = w3;
 assign v1891e5 = w4;
 vcd88e2_v9c7674 v9c7674 (
  .Start(w0),
  .reset(w1),
  .clk(w2),
  .Pulse_100us(w3),
  .Fin(w4)
 );
endmodule

/*-------------------------------------------------*/
/*--   */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- 
/*-------------------------------------------------*/

module vcd88e2_v9c7674 (
 input Start,
 input reset,
 input clk,
 output Pulse_100us,
 output Fin
);
 // cuando llega un tic por Start
 // Se genera un pulso de 100 microsegundos
 // y al terminar se genera un tic de fin del pulso  por "Fin"
 
 parameter      S0=1'b0, S1=1'b1;   // 2 estados inicio y contando/comparando
 reg[31:0]      n=0;                // contador 11 bits hasta 2048, solo necesitamos
                                    // hasta 1200 conteos ( 100 us )
 reg Pulse_100us = 0, Fin = 0;
 reg estadoActual = 0, estadoSiguiente = 0;
 
 //bloque secuencial donde se asigna el estado Siguiente como el estado Actual ***************
 
 always @(posedge clk or posedge reset)
 begin
  if(reset)  estadoActual <= S0;
  else       estadoActual <= estadoSiguiente;
 end
 
 //bloque combinacional donde se calculan las salidas y los estados siguientes ***************
 
 always @(*)begin
 
 //valores por defecto que se aplican si no se indica nada en uno de los estados
 Pulse_100us = 0;
 Fin         = 0;
 n           = 0;
 
   case(estadoActual)
     S0:begin                   // Pulse_100us =0 Fin =0 n =0
          if(Start)              estadoSiguiente = S1;
          else                   estadoSiguiente = S0; 
        end
     S1:begin                   //Pulse_100us = 1 mientras esté en este estado
                                                         Pulse_100us = 1'b1; 
           if(n >= 24000000) begin   estadoSiguiente = S0;    Fin         = 1'b1;     end  // Pulse_100us = 1  n = 0 Fin = 1 
           else              begin   estadoSiguiente = S1;    n           = n + 1;    end  // Pulse_100us = 1  n=n+1 Fin = 0     
        end
     default:                   estadoSiguiente = S0;                              // Pulse_100us = 0  n = 0 Fin = 0
   endcase
 end
 
 
                              
 
endmodule
