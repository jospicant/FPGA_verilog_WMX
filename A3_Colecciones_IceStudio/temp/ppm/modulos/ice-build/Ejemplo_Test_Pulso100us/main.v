// Code generated by Icestudio 0.7.1w202109100309

`default_nettype none

//---- Top entity
module main #(
 parameter v4a33b6 = 1
) (
 input vclk,
 output v1e9581,
 output v034022,
 output v3ce614,
 output [0:7] vinit
);
 localparam p5 = v4a33b6;
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w6;
 wire w7;
 assign v1e9581 = w1;
 assign v034022 = w2;
 assign v3ce614 = w3;
 assign w6 = vclk;
 assign w7 = vclk;
 assign w7 = w6;
 v914278 vdfe1c5 (
  .v7ce33f(w0),
  .v7971ff(w1),
  .v297560(w2),
  .ve643a9(w3),
  .vfc4867(w4),
  .v4fbedb(w6)
 );
 v21cfcc vcc4531 (
  .v9fb85f(w0)
 );
 v519d31 #(
  .vfb06ae(p5)
 ) v3a239a (
  .v2a8434(w4),
  .vac0eb2(w7)
 );
 assign vinit = 8'b00000000;
endmodule

/*-------------------------------------------------*/
/*--   */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- 
/*-------------------------------------------------*/
//---- Top entity
module v914278 (
 input vfc4867,
 input v7ce33f,
 input v4fbedb,
 output v7971ff,
 output v297560,
 output ve643a9
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 assign w1 = vfc4867;
 assign w2 = v7ce33f;
 assign w3 = v4fbedb;
 assign w4 = v4fbedb;
 assign v7971ff = w5;
 assign v297560 = w6;
 assign ve643a9 = w7;
 assign w4 = w3;
 vf1a40e vdae37b (
  .vd33bc4(w0),
  .va0f1da(w2),
  .vbe9682(w3),
  .v8a2f5b(w5),
  .v8b7d1f(w6),
  .v2d5e76(w7)
 );
 v8e2728 vcd7f13 (
  .v2dffca(w0),
  .v10eedb(w1),
  .v0884a0(w4)
 );
endmodule

/*-------------------------------------------------*/
/*-- Pulse100us_W  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Start WITH detector flanco positivo + Creación un pulso de 100us al detectar la señal de Start
/*-------------------------------------------------*/
//---- Top entity
module vf1a40e (
 input vd33bc4,
 input va0f1da,
 input vbe9682,
 output v8a2f5b,
 output v8b7d1f,
 output v2d5e76
);
 wire [0:10] w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 wire w10;
 assign v8a2f5b = w3;
 assign v2d5e76 = w4;
 assign w5 = vd33bc4;
 assign w6 = va0f1da;
 assign w7 = vbe9682;
 assign w8 = vbe9682;
 assign v8b7d1f = w10;
 assign w8 = w7;
 assign w9 = w3;
 v31fc6b vef9835 (
  .v09a468(w0),
  .v678d18(w1),
  .v2e69c1(w2),
  .v5faa99(w3),
  .v1891e5(w4),
  .v826ea3(w5),
  .ve99f77(w6),
  .v30e6b7(w8)
 );
 va05cb9 v604a22 (
  .vee5817(w0),
  .v7c533e(w1),
  .ve61673(w2),
  .vdd729a(w7)
 );
 v35f267 vd274ba (
  .v0e28cb(w9),
  .vcbab45(w10)
 );
endmodule

/*-------------------------------------------------*/
/*-- Pulse100us  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Crea un pulso de 100us al recibir un pulso por Start y manda un tic de fin al acabar el pulso de 100us
/*-------------------------------------------------*/
//---- Top entity
module v31fc6b (
 input [10:0] v09a468,
 input v826ea3,
 input ve99f77,
 input v30e6b7,
 output v5faa99,
 output v2e69c1,
 output v678d18,
 output v1891e5
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire [0:10] w5;
 wire w6;
 wire w7;
 assign w0 = v826ea3;
 assign w1 = ve99f77;
 assign w2 = v30e6b7;
 assign v5faa99 = w3;
 assign v1891e5 = w4;
 assign w5 = v09a468;
 assign v2e69c1 = w6;
 assign v678d18 = w7;
 v31fc6b_v9c7674 v9c7674 (
  .Start(w0),
  .reset(w1),
  .clk(w2),
  .Pulse_100us(w3),
  .Fin(w4),
  .n(w5),
  .reset_n(w6),
  .inc_n(w7)
 );
endmodule

/*-------------------------------------------------*/
/*-- Maquina100us  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- 
/*-------------------------------------------------*/

module v31fc6b_v9c7674 (
 input [10:0] n,
 input Start,
 input reset,
 input clk,
 output Pulse_100us,
 output reset_n,
 output inc_n,
 output Fin
);
 // cuando llega un tic por Start
 // Se genera un pulso de 100 microsegundos
 // y al terminar se genera un tic de fin del pulso  por "Fin"
 
 parameter      S0=1'b0, S1=1'b1;   // 2 estados inicio y contando/comparando
                                    // hasta 1200 conteos ( 100 us )
                                    
 reg Pulse_100us = 0, reset_n =0, inc_n =0, Fin = 0;
 reg estadoActual = 0, estadoSiguiente = 0;
 
 //bloque secuencial donde se asigna el estado Siguiente como el estado Actual ***************
 
 always @(posedge clk or posedge reset)
 begin
  if(reset)  estadoActual <= S0;
  else       estadoActual <= estadoSiguiente;
 end
 
 //bloque combinacional donde se calculan las salidas y los estados siguientes ***************
 
 always @(*)begin
 
 //valores por defecto que se aplican si no se indica nada en uno de los estados
 Pulse_100us = 0;
 reset_n     = 0;
 inc_n       = 0;
 Fin         = 0;
 
   case(estadoActual)
     S0:begin                   
          if(Start)             estadoSiguiente = S1;
          else                  estadoSiguiente = S0;
        end
     S1:begin                   //Pulse_100us = 1 mientras esté en este estado
                                                         Pulse_100us = 1'b1; 
          if(n == 1200) begin   estadoSiguiente = S0;    Fin         = 1;  reset_n = 1;    end  // Pulse_100us = 1  n = 0 Fin = 1 
          else          begin   estadoSiguiente = S1;    inc_n = 1;                        end  // Pulse_100us = 1  n=n+1 Fin = 0     
        end
     default:                   estadoSiguiente = S0;                              // Pulse_100us = 0  n = 0 Fin = 0
   endcase
 end
 
 
                              
 
endmodule
//---- Top entity
module va05cb9 #(
 parameter v5e4a03 = 2048
) (
 input vdd729a,
 input ve61673,
 input v7c533e,
 output [10:0] vee5817,
 output v712cd1
);
 localparam p1 = v5e4a03;
 wire w0;
 wire w2;
 wire w3;
 wire w4;
 wire [0:10] w5;
 assign w0 = ve61673;
 assign w2 = v7c533e;
 assign w3 = vdd729a;
 assign v712cd1 = w4;
 assign vee5817 = w5;
 va05cb9_vbd6086 #(
  .M(p1)
 ) vbd6086 (
  .rst(w0),
  .cnt(w2),
  .clk(w3),
  .ov(w4),
  .q(w5)
 );
endmodule

/*-------------------------------------------------*/
/*-- Contador-11bits-up-rst  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Contador módulo M, ascendente, de 11 bits, con reset 
/*-------------------------------------------------*/

module va05cb9_vbd6086 #(
 parameter M = 0
) (
 input clk,
 input rst,
 input cnt,
 output [10:0] q,
 output ov
);
 //-- Numero de bits del contador
 localparam N = 11; 
 
 //-- En contadores de N bits:
 //-- M = 2 ** N
 
 //-- Internamente usamos un bit mas
 //-- (N+1) bits
 reg [N:0] qi = 0;
 
 always @(posedge clk)
   if (rst | ov)
     qi <= 0;
   else
     if (cnt)
       qi <= qi + 1;
       
 assign q = qi;
 
 //-- Comprobar overflow
 assign ov = (qi == M);
     
endmodule
//---- Top entity
module v35f267 (
 input v0e28cb,
 output vcbab45
);
 wire w0;
 wire w1;
 assign w0 = v0e28cb;
 assign vcbab45 = w1;
 v35f267_vd54ca1 vd54ca1 (
  .a(w0),
  .c(w1)
 );
endmodule

/*-------------------------------------------------*/
/*-- NOT  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Puerta NOT
/*-------------------------------------------------*/

module v35f267_vd54ca1 (
 input a,
 output c
);
 //-- Puerta NOT
 
 //-- module (input wire a, output wire c);
 
 
 assign c = ~a;
 
 
 //-- endmodule
 
endmodule
//---- Top entity
module v8e2728 (
 input v0884a0,
 input v10eedb,
 output v2dffca
);
 wire w0;
 wire w1;
 wire w2;
 assign w0 = v10eedb;
 assign v2dffca = w1;
 assign w2 = v0884a0;
 v8e2728_v115ffb v115ffb (
  .i(w0),
  .o(w1),
  .clk(w2)
 );
endmodule

/*-------------------------------------------------*/
/*-- Subida  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Detector de flanco de subida. Emite un tic cuando detecta un flanco ascendente
/*-------------------------------------------------*/

module v8e2728_v115ffb (
 input clk,
 input i,
 output o
);
 reg q = 0;
 
 always @(posedge clk)
   q <= i;
   
 assign o = (~q & i);  
endmodule
//---- Top entity
module v21cfcc (
 output v9fb85f
);
 wire w0;
 assign v9fb85f = w0;
 v21cfcc_vb2eccd vb2eccd (
  .q(w0)
 );
endmodule

/*-------------------------------------------------*/
/*-- 0  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Un bit constante a 0
/*-------------------------------------------------*/

module v21cfcc_vb2eccd (
 output q
);
 //-- Bit constante a 0
 assign q = 1'b0;
 
 
endmodule
//---- Top entity
module v519d31 #(
 parameter vfb06ae = 100
) (
 input vac0eb2,
 output v2a8434
);
 localparam p2 = vfb06ae;
 wire w0;
 wire w1;
 assign v2a8434 = w0;
 assign w1 = vac0eb2;
 v519d31_v6cac2f #(
  .MS(p2)
 ) v6cac2f (
  .o(w0),
  .clk(w1)
 );
endmodule

/*-------------------------------------------------*/
/*-- Corazon-tic-ms  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Corazón de bombeo de tics a con periodo paramétrico de milisegundos
/*-------------------------------------------------*/

module v519d31_v6cac2f #(
 parameter MS = 0
) (
 input clk,
 output o
);
 //localparam MS;
 
 //-- Constante para dividir y obtener una frecuencia de 1KHz
 localparam M = 12000*MS;
 
 //-- Calcular el numero de bits para almacenar M
 localparam N = $clog2(M);
 
 //-- Cable de reset para el contador
 wire reset;
 
 //-- Registro del divisor
 reg [N-1:0] divcounter;
 
 
 //-- Contador con reset
 always @(posedge clk)
   if (reset)
     divcounter <= 0;
   else
     divcounter <= divcounter + 1;
 
 //-- Comparador que resetea el contador cuando se alcanza el tope
 assign reset = (divcounter == M-1);
 
 //-- La salida es la señal de overflow
 assign o = reset;
 
 
 
 
endmodule
