// Code generated by Icestudio 0.7.1w202109100309

`default_nettype none

//---- Top entity
module main (
 input v35fe10,
 input v357ff7,
 output v980ce1,
 output v5ad277,
 output v9c8ff5,
 output v755ffa,
 output v9653af,
 output vc74257,
 output vd84530,
 output va741a7
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 wire w10;
 wire w11;
 wire w12;
 wire w13;
 wire w14;
 wire w15;
 wire w16;
 assign w0 = v35fe10;
 assign w1 = v357ff7;
 assign w2 = v357ff7;
 assign w4 = v357ff7;
 assign w8 = v357ff7;
 assign v980ce1 = w9;
 assign v5ad277 = w10;
 assign v9c8ff5 = w11;
 assign v755ffa = w12;
 assign v9653af = w13;
 assign vc74257 = w14;
 assign vd84530 = w15;
 assign va741a7 = w16;
 assign w2 = w1;
 assign w4 = w1;
 assign w4 = w2;
 assign w7 = w5;
 assign w8 = w1;
 assign w8 = w2;
 assign w8 = w4;
 v3bfe20 vdbde06 (
  .ve7f5e6(w0),
  .v717e81(w1),
  .v3c12b5(w3)
 );
 veba410 v9b4ca7 (
  .vdd729a(w2),
  .ve61673(w5),
  .v0b79d7(w6)
 );
 v7eacdf vc57c79 (
  .v10eedb(w3),
  .v0884a0(w4),
  .v2dffca(w5)
 );
 v4e712d v263aee (
  .vec8411(w6),
  .v381569(w7),
  .vfc0c62(w8),
  .ve0793c(w9),
  .v86c7f4(w10),
  .v8a6138(w11),
  .v7c09bb(w12),
  .v1f42be(w13),
  .vaf652b(w14),
  .v3317f8(w15),
  .v9c77dc(w16)
 );
endmodule

/*-------------------------------------------------*/
/*-- Dec_PPMx8  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Decodificador 8 canales PPM
/*-------------------------------------------------*/
//---- Top entity
module v3bfe20 (
 input v717e81,
 input ve7f5e6,
 output v3c12b5
);
 wire w0;
 wire w1;
 wire w2;
 assign w0 = ve7f5e6;
 assign w1 = v717e81;
 assign v3c12b5 = w2;
 v3bfe20_v683a9f v683a9f (
  .i(w0),
  .clk(w1),
  .o(w2)
 );
endmodule

/*-------------------------------------------------*/
/*-- Sync  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Sincronizar las entradas de datos con el reloj del sistema
/*-------------------------------------------------*/

module v3bfe20_v683a9f (
 input clk,
 input i,
 output o
);
 // Sincronizacion. Evitar 
 // problema de la metaestabilidad
 
 reg d1;
 reg d2;
 
 always @(posedge clk)
  d1 <= i;
  
 always @(posedge clk)
   d2 <= d1;
   
 assign o = d2;
endmodule
//---- Top entity
module veba410 (
 input ve61673,
 input vdd729a,
 output v0b79d7
);
 wire w0;
 wire w1;
 wire w2;
 assign w0 = vdd729a;
 assign w1 = ve61673;
 assign v0b79d7 = w2;
 veba410_vbd6086 vbd6086 (
  .clk(w0),
  .rst(w1),
  .ov(w2)
 );
endmodule

/*-------------------------------------------------*/
/*-- Overflow_4ms  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Contador Reset y overflow a los 4ms
/*-------------------------------------------------*/

module veba410_vbd6086 (
 input rst,
 input clk,
 output ov
);
 
 reg [15:0] qi = 0;
 
 always @(posedge clk)
   if (rst | ov)  qi <= 0;
   else           qi <= qi + 1;
       
 //-- Comprobar overflow
 assign ov = (qi == 48000 );
     
endmodule
//---- Top entity
module v7eacdf (
 input v0884a0,
 input v10eedb,
 output v2dffca
);
 wire w0;
 wire w1;
 wire w2;
 assign w0 = v10eedb;
 assign v2dffca = w1;
 assign w2 = v0884a0;
 v7eacdf_v115ffb v115ffb (
  .i(w0),
  .o(w1),
  .clk(w2)
 );
endmodule

/*-------------------------------------------------*/
/*-- Bajada  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Detector de flanco de bajada. Emite un tic cuando detecta un flanco descendente
/*-------------------------------------------------*/

module v7eacdf_v115ffb (
 input clk,
 input i,
 output o
);
 reg q = 0;
 
 always @(posedge clk)
   q <= i;
   
 assign o = (q & ~i);  
endmodule
//---- Top entity
module v4e712d (
 input v381569,
 input vec8411,
 input vfc0c62,
 output ve0793c,
 output v86c7f4,
 output v8a6138,
 output v7c09bb,
 output v1f42be,
 output vaf652b,
 output v3317f8,
 output v9c77dc
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 wire w10;
 assign w0 = vec8411;
 assign w1 = vfc0c62;
 assign w2 = v381569;
 assign ve0793c = w3;
 assign v86c7f4 = w4;
 assign v8a6138 = w5;
 assign v7c09bb = w6;
 assign v1f42be = w7;
 assign vaf652b = w8;
 assign v3317f8 = w9;
 assign v9c77dc = w10;
 v4e712d_vee177d vee177d (
  .reset(w0),
  .clk(w1),
  .InPPM_neg(w2),
  .Ch1(w3),
  .Ch2(w4),
  .Ch3(w5),
  .Ch4(w6),
  .Ch5(w7),
  .Ch6(w8),
  .Ch7(w9),
  .Ch8(w10)
 );
endmodule

/*-------------------------------------------------*/
/*-- Deco_PPM_8  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Decodificador PPM 8 canales
/*-------------------------------------------------*/

module v4e712d_vee177d (
 input InPPM_neg,
 input reset,
 input clk,
 output Ch1,
 output Ch2,
 output Ch3,
 output Ch4,
 output Ch5,
 output Ch6,
 output Ch7,
 output Ch8
);
 
 parameter [3:0] S0=0, S1=1, S2=2, S3=3, S4=4, S5=5, S6=6, S7=7, S8=8;              //Poner nombres a los estados
 
 reg Ch1=0, Ch2=0, Ch3=0, Ch4=0, Ch5=0, Ch6=0, Ch7=0, Ch8=0;                        //Inicializo canales
 
 reg [3:0]  estadoActual=0, estadoNext=0;                                           //Inicializo estados
 
 // bloque secuencial. Capturar estado Actual
 
 always @(posedge clk )
 if(reset) estadoActual <= S0; 
 else estadoActual <= estadoNext;
 
 // Bloque combinacional. Calculamos estado siguiente y valor de las
 // salidas en función de las entradas y del estado actual.
 
 always @(reset or InPPM_neg or estadoActual)  //  estado siguiente = función ( entradas y estado actual)
 begin
   //valores por defecto. justo antes del case pongo valores por defecto y en el case solo cambiamos
   //la salida que se ve afectada y las demás tomarán los valores por defecto
   Ch1   = 0;   Ch2   = 0;   Ch3   = 0;   Ch4   = 0; 
   Ch5   = 0;   Ch6   = 0;   Ch7   = 0;   Ch8   = 0;
   estadoNext   = 'bx; 
   
   case(estadoActual)  //Evaluación del estado actual
      S0:begin                                   
         if( InPPM_neg  )  begin   estadoNext = S1;   Ch1 = 1'b1;   end 
         else                      estadoNext = S0;  
         end
      S1:begin                                   
         if( InPPM_neg  )  begin   estadoNext = S2;   Ch2 = 1'b1;   end 
         else              begin   estadoNext = S1;   Ch1 = 1'b1;   end
         end
      S2:begin                                   
         if( InPPM_neg  )  begin   estadoNext = S3;   Ch3 = 1'b1;   end 
         else              begin   estadoNext = S2;   Ch2 = 1'b1;   end
         end
      S3:begin                                   
         if( InPPM_neg  )  begin   estadoNext = S4;   Ch4 = 1'b1;   end 
         else              begin   estadoNext = S3;   Ch3 = 1'b1;   end
         end
      S4:begin                                   
         if( InPPM_neg  )  begin   estadoNext = S5;   Ch5 = 1'b1;   end 
         else              begin   estadoNext = S4;   Ch4 = 1'b1;   end
         end
      S5:begin                                   
         if( InPPM_neg  )  begin   estadoNext = S6;   Ch6 = 1'b1;   end 
         else              begin   estadoNext = S5;   Ch5 = 1'b1;   end
         end
      S6:begin                                   
         if( InPPM_neg  )  begin   estadoNext = S7;   Ch7 = 1'b1;   end 
         else              begin   estadoNext = S6;   Ch6 = 1'b1;   end
         end
      S7:begin                                   
         if( InPPM_neg  )  begin   estadoNext = S8;   Ch8 = 1'b1;   end 
         else              begin   estadoNext = S7;   Ch7 = 1'b1;   end
         end
      S8:begin                                   
         if( InPPM_neg  )          estadoNext = S0;
         else              begin   estadoNext = S8;   Ch8 = 1'b1;  end
         end
      default:                     estadoNext = S0;
    endcase
 end
endmodule
