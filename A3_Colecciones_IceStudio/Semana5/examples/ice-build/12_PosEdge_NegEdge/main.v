// Code generated by Icestudio 0.7.1w202109100309

`default_nettype none

//---- Top entity
module main #(
 parameter ve85ee0 = 10
) (
 input v4c960c,
 input vclk,
 output [2:0] v8d5ddb,
 output [2:0] v965915,
 output [0:1] vinit
);
 localparam p3 = ve85ee0;
 wire [0:2] w0;
 wire [0:2] w1;
 wire w2;
 wire w4;
 wire w5;
 assign v8d5ddb = w0;
 assign v965915 = w1;
 assign w4 = v4c960c;
 assign w5 = vclk;
 v5b3e69 #(
  .v207e0d(p3)
 ) vba2abd (
  .v8337bc(w2),
  .v531e20(w5)
 );
 main_veb3b88 veb3b88 (
  .e(w0),
  .f(w1),
  .clk(w2),
  .reset(w4)
 );
 assign vinit = 2'b00;
endmodule

/*-------------------------------------------------*/
/*--   */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- 
/*-------------------------------------------------*/
//---- Top entity
module v5b3e69 #(
 parameter v207e0d = 1
) (
 input v531e20,
 output v8337bc
);
 localparam p2 = v207e0d;
 wire w0;
 wire w1;
 assign v8337bc = w0;
 assign w1 = v531e20;
 v5b3e69_v94c6d7 #(
  .SEG(p2)
 ) v94c6d7 (
  .clk_o(w0),
  .clk(w1)
 );
endmodule

/*-------------------------------------------------*/
/*-- Corazon_Seg  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Bombear 1 bit con el periodo especificado en el parámetro. Por defecto el periodo es de 1 segundos
/*-------------------------------------------------*/

module v5b3e69_v94c6d7 #(
 parameter SEG = 0
) (
 input clk,
 output clk_o
);
 
 //parameter HZ=1;
 
 //-- Constante para dividir y obtener una frecuencia de 1Hz
 localparam M = 12000000*SEG;
 
 //-- Calcular el numero de bits para almacenar M
 localparam N = $clog2(M);
 
 //-- Registro del divisor
 reg [N-1:0] divcounter;
 
 //-- Temporal clock
 reg clk_t = 0;
 
 //-- Se usa un contador modulo M/2 para luego
 //-- pasarlo por un biestable T y dividir la frecuencia
 //-- entre 2, para que el ciclo de trabajo sea del 50%
 always @(posedge clk)
     if (divcounter == M/2) begin
       clk_t <= 1;
       divcounter = 0;
     end 
     else begin
       divcounter <=  divcounter + 1;
       clk_t = 0;
     end 
   
 reg clk_o = 0;  
     
 //-- Biestable T para obtener ciclo de trabajo del 50%
 always @(posedge clk)
   if (clk_t)
     clk_o <= ~clk_o;
 
endmodule

module main_veb3b88 (
 input reset,
 input clk,
 output [2:0] e,
 output [2:0] f
);
 // module Nobloqueante(input reset, input clk, output [2:0] e, output [2:0] f);
 
 // asignación NO BLOQUEANTE <=  
 // No importa el orden.  Primero se ejecutan las acciones a la derecha de la asignación ( RHS)
 // y al final del always se asignan todos a la izquierda.
 
 // En este caso podemos ver un intercambio en cada ciclo de reloj
 
 reg [2:0] a=7;       // 7
 reg [2:0] b=5;       // 5
 
 
 // originalmente a = 7  b=5
 
 always @(posedge clk or negedge reset)  //Verifica pero no construye... no se puede instanciar
 begin                                 // biestable con una entrada con flanco positivo y otra negativa
 
 // if(!reset)    //con (!reset) si  encuentra instancia con  reset no encuentra instancia
 // No tiene sentido poner negedge reset y poner  if(reset) por lo que no encuentra instancia
  if(reset)  // Reset Asíncrono... Se produce en cuanto se pulse
   begin
     a<=7;           //Carga valores
     b<=5;
   end
   
  else
   begin             
     a <= b;        // Intercambia
     b <= a;             
   end
   
 end
 
 assign e = a;      //Asignación
 assign f = b;
 
 //endmodule
endmodule
